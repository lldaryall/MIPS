Darya Pylypenko
dp24s

PA3 C program Cache Simulation

1. Objective:
            -understanding :
                           caching
                           tags
                           indices
                           offsets
                           cache replacement
                           writeback policies
                           iterating arrays in C
               
2. Description:
            This project requires you to read in a bunch of memory references and simulate the operation of a write-through, no-write-allocate cache and a write-back, write-allocate cache

2.1 Write Policies:         
            -Write-through and no write-allocate cache
            - Write-back and write-allocate cache
            - Correctly redirected input using stdin, with first 3 lines being   block size, number of sets, associativity, followed by at most 100 lines of memory references, in the format: 

2.2 Input:            
                           R/W<tab>address
            - where R/W will be either 'R' or 'W'
            - address will be a 32 bit positive integer

2.3 Output:
      Prints output using stdout, in the format:
               Block size:
               Number of sets:
               Associativity:
               Number of offset bits:
               Number of index bits:
               Number of tag bits:
               ****************************************
               Write-through with No Write Allocate
               ****************************************
               Total number of references: 
               Hits: 
               Misses: 
               Memory References: 
               ****************************************
               Write-back with Write Allocate
               ****************************************
               Total number of references: 
               Hits: 
               Misses: 
               Memory References: 

3. Dynamic Allocation in C:

3.1 Declaration
    Implemented dynamically allocated arrays 
            -using malloc found in stdlib library to create an array of integers:
                  int * arr = (int *) malloc (size_of_array * sizeof(int));
            -For an array of the cache structure, which has been typedef'ed is:
                  Cache *cache = (Cache*) malloc(sizeof(Cache));

3.2 Deallocating
            -Deallocated dynamically allocated memory using:
                  free(pointer);
            -Used C concepts
            -used #define to declare constants and variables
            - declared all variables at the beginning of function
            - used C commands such as printf, scanf, fgets, and atoi
            - implemented proper memory management with malloc/free
            - used structures for cache organization
            - implemented LRU replacement policy with global counter
            - handled cache conflicts and associativity correctly

4. Extra Credit:
            -split I vs. D caches separately cache instruction and data references in their own L1 caches
            -Assume that each sub-cache receives half the number of sets (s/2) so that the total size is the same between the two implementations. Instructions are read-only, so the Write policies do not matter for I-cache

4.1 Input:
            -similar input instructions to normal, but with the addition of 'I' and 'D'
               R/W<tab>address<tab>I/D

4.2 Output:
               output format:
               ================ Unified ================
               Block size: 
               Number of sets: 
               Associativity: 
               Number of offset bits: 
               Number of index bits: 
               Number of tag bits: 
               ****************************************
               Write-through with No Write Allocate
               ****************************************
               Total number of references: 
               Hits:
               Misses: 
               Memory References: 
               ****************************************
               Write-back with Write Allocate
               ****************************************
               Total number of references: 
               Hits: 
               Misses: 
               Memory References: 
               ============= Split I vs. D =============
               Block size: 
               Number of sets: 
               Associativity: 
               Number of offset bits: 
               Number of index bits: 
               Number of tag bits: 
               ****************************************
               Instructions:
               ****************************************
               Total number of references: 
               Hits: 
               Misses: 
               Memory References: 
               ****************************************
               Data: Write-through with No Write Allocate
               ****************************************
               Total number of references: 
               Hits: 
               Misses: 
               Memory References: 
               ****************************************
               Data: Write-back with Write Allocate
               ****************************************
               Total number of references: 
               Hits: 
               Misses: 
               Memory References: 

5. Testing:

            8 test cases:

          -test1.basic.in - basic cache operations 
          -test2.associative.in - 2 way set associative cache testing
          -test3.writeTandB.in - Write-through vs write-back policy comparison
          -test4.dirty.in - dirty block testing
          -test5.splitCache.in - Split I/D cache functionality
          -test6.large.in - testing large size 
          -test7.readWrite.in - read and write operations
          -test8.repeated.in - repeated

         All tests work successfully and produce correct output.

6. Compiling and Running:
            - should be run and compiled on linprog with the following commands,
              where test.in is a cache trace file, as described below:
                  $ gcc PA3_EC.c -lm
                  $ ./a.out < test.in

            Example:
                  $ gcc PA3_EC.c -lm
                  $ ./a.out < test1.basic.in

Known Issues:

   -None that I am aware of, it can do:
         -Reading and parsing 
         -Calculating the bits for tag, index and offset 
         -Setting up the arrays for the cache 
         -Implementing Least Recently Used Policy 
         -Managing Associativity 
         -Simulating a write-through, no-write allocate cache 
         -Simulating a write-back, write allocate cache 
         -Quality of the test suite 
         -Extra Credit - Split I and D caches 

The program has been tested with the provided test cases and additional tests and produces correct output matching the expected results.
